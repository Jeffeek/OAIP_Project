Инициализация экземпляра вложенного класса в С++

Если класс является агрегатом, то есть в качестве своих атрибутов содержит экземпляры каких-то других классов, возникают вопросы о способе и времени конструирования данных экземпляров. Ведь для каждого объекта при его создании должен быть вызван один из его конструкторов.

Время вызова конструкторов классов-атрибутов — непосредственно перед вызовом конструктора класса-агрегата.

Перед вызовом конструктора класса инициализируются все его члены. Если у вложенного класса есть конструктор без параметров, то будет вызван он. Однако, если у вложенного класса отсутствует явно или неявно заданный конструктор без параметров, то должно быть место, где он явно вызывается.

Итак, инициализация экземпляра вложенного класса через вызов конструктора не по умолчанию происходит в списке инициализации членов класса.

Определение
Список инициализации членов класса — это строка, следующая за заголовком конструктора класса в месте его реализации.

Если класс некоторого поля не содержит конструктора по умолчанию (без параметров) и поле не упоминаертся в списке инициализации — то при попытке компиляции будет получено сообщение об ошибке.

class Player{
    string name;
public:
    Player(string name) {_name = name;}
};
class Team{
    public:
        void Team(): b("Michael Schumacher"), a("Gary Anderson")
        {
            //к этому моменту конструкторы классов-атрибутов уже вызваны
            //последовательность вызова конструкторов a и b определяется
            //их последовательностьюв не в списке инициализации,
            //а при описании тела класса.
            //Т.е. вначале будет вызван конструктор для a, и затем для b
        }
    private:
        Player a, b;
};
В списке инициализации могут быть инициализированы атрибуты не только классовых, но и стандартных типов:

struct AltStruct {
    AltStruct(int x, double y) : x_(x), y_(y) {}
 
private:
    int x_;
    double y_;
};